/*
 * generated by Xtext 2.28.0
 */
package org.eclipse.emf.emfatic.xtext.validation;

import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.stream.Stream;

import org.apache.log4j.Logger;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreValidator;
import org.eclipse.emf.emfatic.xtext.annotations.AnnotationMap;
import org.eclipse.emf.emfatic.xtext.common.ImportUriChecker;
import org.eclipse.emf.emfatic.xtext.emfatic.Annotation;
import org.eclipse.emf.emfatic.xtext.emfatic.ClassDecl;
import org.eclipse.emf.emfatic.xtext.emfatic.ClassMember;
import org.eclipse.emf.emfatic.xtext.emfatic.ClassMemberDecl;
import org.eclipse.emf.emfatic.xtext.emfatic.ClassifierDecl;
import org.eclipse.emf.emfatic.xtext.emfatic.CompUnit;
import org.eclipse.emf.emfatic.xtext.emfatic.Declaration;
import org.eclipse.emf.emfatic.xtext.emfatic.Details;
import org.eclipse.emf.emfatic.xtext.emfatic.EmfaticPackage;
import org.eclipse.emf.emfatic.xtext.emfatic.EnumLiteral;
import org.eclipse.emf.emfatic.xtext.emfatic.Feature;
import org.eclipse.emf.emfatic.xtext.emfatic.Import;
import org.eclipse.emf.emfatic.xtext.emfatic.Operation;
import org.eclipse.emf.emfatic.xtext.emfatic.PackageDecl;
import org.eclipse.emf.emfatic.xtext.emfatic.Param;
import org.eclipse.emf.emfatic.xtext.emfatic.StringOrQualifiedID;
import org.eclipse.emf.emfatic.xtext.emfatic.SubPackageDecl;
import org.eclipse.emf.emfatic.xtext.emfatic.TopLevelDecl;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.resource.FileExtensionProvider;
import org.eclipse.xtext.validation.Check;

import com.google.common.base.Objects;
import com.google.inject.Inject;

/**
 * The validaiton of Emfatic models is composed of Emfatic and Ecore constraints.
 * 
 *  For Emfatic we want to
 *  <ul>
 *  	<i> Ecore metamodel is not imported
 *  	<i> Validate that imports exist
 *  </ul>
 *  <p>
 *  TODO For Ecore we should use the {@link EcoreValidator} and translate those errors to Xtext ones
 *  TODO Foe Ecore we should create the emfatic-2-ecore mapper first
 */
public class EmfaticValidator extends AbstractEmfaticValidator {
	
	/**
	 * Warn if Ecore metamodel is loaded
	 */
	@Check
	public void checkEcoreMetamodelImported(Import imprt) {
		String literalURI = imprt.getUri().getLiteral();
		if (literalURI != null && 
				Objects.equal(literalURI, EcorePackage.eINSTANCE.getNsURI())) {
			warning(
					"Ecore metemodel is imported by default.",
					EmfaticPackage.Literals.IMPORT__URI,
					IssueCodes.W_ECORE_IMPORTED,
					"");
		}
	}
	
	/**
	 * Check that the URI is valid and that it's not an empty resource
	 * @param imprt
	 */
	@Check
	public void checkImportedUriIsValid(Import imprt) {
		ImportUriChecker checker = new ImportUriChecker(imprt.eResource(), this.fileExtensionProvider);
		Optional<URI> optUri = checker.resolveURI(imprt);
		try {
			optUri = checker.resolveURI(imprt);
		} catch (Exception e) {
			error(
				"Invalid uri '" + checker.uriString(imprt) + "'",
				EmfaticPackage.Literals.IMPORT__URI,
				IssueCodes.E_INVALID_METAMODEL_IMPORTED,
				""); 
		}
		if (optUri.isPresent()) {
			URI uri = optUri.get();
			if (!checker.isValidResoruce(uri)) {
				error(
					"Invalid uri file extension. Can only import *.ecore and " 
							+ checker.validExtensions()
							+ " models.",
					EmfaticPackage.Literals.IMPORT__URI,
					IssueCodes.E_INVALID_METAMODEL_IMPORTED,
					""); 
			} else if (!checker.resourceExists(uri)) {
				error(
						"Unable to load metamodel with uri '" + uri.toString() + "'. Resource was not found.",
						EmfaticPackage.Literals.IMPORT__URI,
						IssueCodes.E_INVALID_METAMODEL_IMPORTED,
						"");
			} else {
				Resource metamodelResource = EcoreUtil2.getResource(imprt.eResource(), uri.toString());
				if (metamodelResource != null && metamodelResource.getContents().isEmpty()) {
					warning(
							"Metamodel with uri '" + uri + "' is empty. Check the URI and/or target file.",
							EmfaticPackage.Literals.IMPORT__URI,
							IssueCodes.W_EMPTY_METAMODEL,
							"");
				}
			}
		}
	}
	
	/**
	 * Check for self inheritance in ClassDecl
	 */
	@Check
	public void checkSelfInheritance(ClassDecl classDecl) {
		if(classDecl.getSuperTypes().stream()
			.map(bc -> bc.getBound())
			.anyMatch(cd -> classDecl.equals(cd))) {
			error(
				"Cycle detected: the type '" + classDecl.getName() + "' cannot extend itself",
				EmfaticPackage.Literals.CLASS_DECL__SUPER_TYPES,
				IssueCodes.E_EXTEND_CYCLE_DETECTED,
				""); 
		}
	}
	
	/**
	 * Check that he annotation label has been previously defined.
	 */
	@Check
	public void checkValidLabel(final Annotation annt) {
		StringOrQualifiedID source = annt.getSource();
		var label = source.getId();
		if (label != null) {
			if(!this.annotationMap.knowsLabel(label, annt.eResource())) {
				error(
						"Unknown annotation label '" + label + "'. This can mean you are "
								+ "missing an EmfaticAnnotationMap to define a custom label "
								+ "or there is a missing dependency (label provided via "
								+ "extension point). Remember that URIs must be within double quotes.",
						EmfaticPackage.Literals.ANNOTATION__SOURCE,
							IssueCodes.E_UNKOWN_ANNOTATION_LABEL,
							""); 
			}
		} else {
			label = this.annotationMap.labelForUri(source.getLiteral(), annt.eResource());
			if (label != null) {
				warning(
						"The key uri " + source.getLiteral() + " can be replaced by its label: " + label,
						EmfaticPackage.Literals.ANNOTATION__SOURCE,
						IssueCodes.W_URI_INSTEAD_OF_LABEL,
						label);
			}
		}
	}
	
	/**
	 * Check that annotation is not assigning duplicate keys
	 */
	@Check
	public void checkDuplicateKeys(final Details entry) {
		Annotation annt = (Annotation) entry.eContainer();
		if (annt.getDetails().stream().anyMatch(d -> d != entry && d.getKey().equals(entry.getKey()))) {
			error(
					"Duplicate key detected: " + entry.getKey(),
					EmfaticPackage.Literals.DETAILS__KEY,
					IssueCodes.E_DUPLICATE_KEY_FOUND,
					entry.getKey()); 
		}
	}
	
	/**
	 * Check that the key is valid for the EObject to which the annotation is attached
	 */
	@Check
	public void checkValidDetails(Details entry) {
		Annotation annt = (Annotation) entry.eContainer();
		annotationTarget(annt.eContainer()).ifPresent(target ->
			resolveLabel(annt). ifPresent(label -> {
				try {
					if (!this.annotationMap.isValidKey(label, entry.getKey(), target, annt.eResource())) {
						warning(
								"The key '" + entry.getKey() + "' is not a valid key for " + target.getName() + " elements.",
								EmfaticPackage.Literals.DETAILS__KEY,
								IssueCodes.W_INVALID_KEY_USED,
								entry.getKey());
					}
				} catch (IllegalArgumentException e) {
					LOG.error("Testing for the label already done, should never get here");
					throw e;
				}
			})
		);
	}
	
	/**
	 * Check that ClassDecl have unique names within their PackDecl
	 */
	@Check
	public void checkClassDeclUniqueName(ClassifierDecl entry) {
		TopLevelDecl topLvlDecl = (TopLevelDecl) entry.eContainer();
		EObject context = topLvlDecl.eContainer();
		Stream<Declaration> otherClassDecl = null;
		if (Objects.equal(context.eClass(), EmfaticPackage.Literals.COMP_UNIT)) {
			CompUnit compUnit = (CompUnit) context;
			otherClassDecl = compUnit.getDeclarations().stream()
					.map(tld -> tld.getDeclaration())
					.filter(d -> d != entry);		
		} else if (Objects.equal(context.eClass(), EmfaticPackage.Literals.SUB_PACKAGE_DECL)) {
			SubPackageDecl pckDecl = (SubPackageDecl) context;
			otherClassDecl = pckDecl.getDeclarations().stream()
					.map(tld -> tld.getDeclaration())
					.filter(d -> d != entry);	
		} else {
			return;
		}
		otherClassDecl.forEach(oc -> {
			if (oc instanceof ClassifierDecl && oc.getName().equals(entry.getName())) {
				error(
						"Duplicate names detected: " + entry,
						EmfaticPackage.Literals.DECLARATION__NAME,
						IssueCodes.E_DUPLICATE_CLASS_NAME,
						oc.getName());
			}
		});
	}
	
	/**
	 * Check that Features have unique names within their class
	 */
	@Check
	public void checkFeatureUniqueName(Feature entry) {
		ClassMemberDecl decl = (ClassMemberDecl) entry.eContainer();
		ClassDecl classDecl = (ClassDecl) decl.eContainer();
		classDecl.getMembers().stream()
			.map(cm -> cm.getMember())
			.filter(cm -> (cm instanceof Feature) && cm != entry)
			.forEach(f -> {
				if (f.getName().equals(entry.getName())) {
					error(
							"Duplicate names detected: " + entry,
							EmfaticPackage.Literals.CLASS_MEMBER__NAME,
							IssueCodes.E_DUPLICATE_FEATURE_NAME,
							f.getName());
				}
			});
	}
	
	/**
	 * Check that Operations have unique names within their class
	 */
	@Check
	public void checkOperationUniqueName(Operation entry) {
		ClassMemberDecl decl = (ClassMemberDecl) entry.eContainer();
		ClassDecl classDecl = (ClassDecl) decl.eContainer();
		classDecl.getMembers().stream()
				.map(cm -> cm.getMember())
				.filter(cm -> (cm instanceof Operation) && cm != entry)
				.forEach(op -> {
					if (op.getName().equals(entry.getName())) {
						error(
								"Duplicate names detected: " + entry,
								EmfaticPackage.Literals.CLASS_MEMBER__NAME,
								IssueCodes.E_DUPLICATE_OPERATION_NAME,
								op.getName()); 
					}
		});
	}
	
	@Inject
	private FileExtensionProvider fileExtensionProvider;
	
	@Inject
	private AnnotationMap annotationMap;
	
	private final static Logger LOG = Logger.getLogger(EmfaticValidator.class);

	private Optional<EClass> annotationTarget(EObject anntOwner) {
		EClass target = null;
		if (anntOwner instanceof PackageDecl) {
			target = anntOwner.eClass();
		} else if (anntOwner instanceof TopLevelDecl) {
			TopLevelDecl tpLvlDclrtn = (TopLevelDecl) anntOwner;
			Declaration declaration = tpLvlDclrtn.getDeclaration();
			if (declaration != null) {
				target = declaration.eClass();
			}
		} else if (anntOwner instanceof ClassMemberDecl) {
			ClassMemberDecl declaration = (ClassMemberDecl) anntOwner;
			ClassMember member = declaration.getMember();
			if (member != null) {
				target = member.eClass();
			}
		} else if (anntOwner instanceof Param) {
			target = anntOwner.eClass();
		} else if (anntOwner instanceof EnumLiteral) {
			target = anntOwner.eClass();
		}
		return Optional.ofNullable(target);
	}
	
	private Optional<String> resolveLabel(Annotation annt) {
		StringOrQualifiedID source = annt.getSource();
		String label = null;
		label = source.getId();
		if (label == null) {
			try {
				label = this.annotationMap.labelForUri(source.getLiteral(), annt.eResource());
			} catch (NoSuchElementException e) {
				// People may use arbitrary URIs at any point
				LOG.warn("Non-registered Annotation URI used: " + source.getLiteral());
			}
		}
		return Optional.ofNullable(label);
	}
	
	
}
