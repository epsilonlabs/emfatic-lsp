/*
 * generated by Xtext 2.28.0
 */
package org.eclipse.emf.emfatic.xtext.validation;

import java.util.NoSuchElementException;
import java.util.Optional;

import org.apache.log4j.Logger;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreValidator;
import org.eclipse.emf.emfatic.xtext.annotations.AnnotationMap;
import org.eclipse.emf.emfatic.xtext.common.ImportUriChecker;
import org.eclipse.emf.emfatic.xtext.emfatic.Annotation;
import org.eclipse.emf.emfatic.xtext.emfatic.ClassDecl;
import org.eclipse.emf.emfatic.xtext.emfatic.ClassMember;
import org.eclipse.emf.emfatic.xtext.emfatic.ClassMemberDecl;
import org.eclipse.emf.emfatic.xtext.emfatic.Declaration;
import org.eclipse.emf.emfatic.xtext.emfatic.Details;
import org.eclipse.emf.emfatic.xtext.emfatic.EmfaticPackage;
import org.eclipse.emf.emfatic.xtext.emfatic.EnumLiteral;
import org.eclipse.emf.emfatic.xtext.emfatic.Import;
import org.eclipse.emf.emfatic.xtext.emfatic.PackageDecl;
import org.eclipse.emf.emfatic.xtext.emfatic.Param;
import org.eclipse.emf.emfatic.xtext.emfatic.StringOrQualifiedID;
import org.eclipse.emf.emfatic.xtext.emfatic.TopLevelDecl;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.resource.FileExtensionProvider;
import org.eclipse.xtext.validation.Check;

import com.google.common.base.Objects;
import com.google.inject.Inject;

/**
 * The validaiton of Emfatic models is composed of Emfatic and Ecore constraints.
 * 
 *  For Emfatic we want to
 *  <ul>
 *  	<i> Ecore metamodel is not imported
 *  	<i> Validate that imports exist
 *  </ul>
 *  <p>
 *  TODO For Ecore we should use the {@link EcoreValidator} and translate those errors to Xtext ones
 *  TODO Foe Ecore we should create the emfatic-2-ecore mapper first
 */
public class EmfaticValidator extends AbstractEmfaticValidator {
	
	@Check
	public void checkEcoreMetamodelImported(Import imprt) {
		String literalURI = imprt.getUri().getLiteral();
		if (literalURI != null && 
				Objects.equal(literalURI, EcorePackage.eINSTANCE.getNsURI())) {
			warning(
					"Ecore metemodel is imported by default.",
					EmfaticPackage.Literals.IMPORT__URI,
					IssueCodes.INVALID_METAMODEL_IMPORTED,
					"");
		}
	}
	
	@Check
	public void checkImportedUriIsValid(Import imprt) {
		ImportUriChecker checker = new ImportUriChecker(imprt.eResource(), this.fileExtensionProvider);
		Optional<URI> optUri = checker.resolveURI(imprt);
		try {
			optUri = checker.resolveURI(imprt);
		} catch (Exception e) {
			error(
				"Invalid uri '" + checker.uriString(imprt) + "'",
				EmfaticPackage.Literals.IMPORT__URI,
				IssueCodes.INVALID_METAMODEL_IMPORTED,
				""); 
		}
		if (optUri.isPresent()) {
			URI uri = optUri.get();
			if (!checker.isValidResoruce(uri)) {
				error(
					"Invalid uri file extension. Can only import *.ecore and " 
							+ checker.validExtensions()
							+ " models.",
					EmfaticPackage.Literals.IMPORT__URI,
					IssueCodes.INVALID_METAMODEL_IMPORTED,
					""); 
			} else if (!checker.resourceExists(uri)) {
				error(
						"Unable to load metamodel with uri '" + uri.toString() + "'. Resource was not found.",
						EmfaticPackage.Literals.IMPORT__URI,
						IssueCodes.INVALID_METAMODEL_IMPORTED,
						"");
			} else {
				Resource metamodelResource = EcoreUtil2.getResource(imprt.eResource(), uri.toString());
				if (metamodelResource != null && metamodelResource.getContents().isEmpty()) {
					warning(
							"Metamodel with uri '" + uri + "' is empty. Check the URI and/or target file.",
							EmfaticPackage.Literals.IMPORT__URI,
							IssueCodes.INVALID_METAMODEL_IMPORTED,
							"");
				}
			}
		}
	}
	
	@Check
	public void checkSelfInheritance(ClassDecl classDecl) {
		if(classDecl.getSuperTypes().stream()
			.map(bc -> bc.getBound())
			.anyMatch(cd -> classDecl.equals(cd))) {
			error(
				"Cycle detected: the type '" + classDecl.getName() + "' cannot extend itself",
				EmfaticPackage.Literals.CLASS_DECL__SUPER_TYPES,
				IssueCodes.EXTEND_CYCLE_DETECTED,
				""); 
		}
	}
	
	@Check
	public void checkValidLabel(final Annotation annt) {
		annotationTarget(annt.eContainer()).ifPresent((target) ->
			resolveLabel(annt).ifPresentOrElse(label -> {
					if(!this.annotationMap.knowsLabel(label, annt.eResource())) {
						error(
								"Unknown annotation label '" + label + "'. This can mean you are "
										+ "missing an EmfaticAnnotationMap to define a custom label "
										+ "or there is a missing dependency (label provided via "
										+ "extension point).",
								EmfaticPackage.Literals.ANNOTATION__SOURCE,
									IssueCodes.UNKOWN_ANNOTATION_LABEL,
									""); 
					}
				}, () -> {
					StringOrQualifiedID source = annt.getSource();
					warning(
							"The key uri " + source.getLiteral() + " can be replaced by its label.",
							EmfaticPackage.Literals.ANNOTATION__SOURCE,
							IssueCodes.URI_INSTEAD_OF_LABEL,
							source.getLiteral());
				})
			);
	}
	
	@Check
	public void checkDuplicateKeys(final Details entry) {
		Annotation annt = (Annotation) entry.eContainer();
		if (annt.getDetails().stream().anyMatch(d -> d != entry && d.getKey().equals(entry.getKey()))) {
			error(
					"Duplicate key detected: " + entry.getKey(),
					EmfaticPackage.Literals.DETAILS__KEY,
					IssueCodes.DUPLICATE_KEY_FOUND,
					entry.getKey()); 
		}
	}
	
	@Check
	public void checkValidMapEntry(Details entry) {
		Annotation annt = (Annotation) entry.eContainer();
		annotationTarget(annt.eContainer()).ifPresent(target ->
			resolveLabel(annt). ifPresent(label -> {
				try {
					if (!this.annotationMap.isValidKey(label, entry.getKey(), target, annt.eResource())) {
						warning(
								"The key '" + entry.getKey() + "' is not a valid key for " + target.getName() + " elements.",
								EmfaticPackage.Literals.DETAILS__KEY,
								IssueCodes.INVALID_KEY_USED,
								"");
					}
				} catch (IllegalArgumentException e) {
					LOG.error("Testing for the label already done, should never get here");
					throw e;
				}
			})
		);
	}
	
	@Inject
	private FileExtensionProvider fileExtensionProvider;
	
	@Inject
	private AnnotationMap annotationMap;
	
	private final static Logger LOG = Logger.getLogger(EmfaticValidator.class);

	private Optional<EClass> annotationTarget(EObject anntOwner) {
		EClass target = null;
		if (anntOwner instanceof PackageDecl) {
			target = anntOwner.eClass();
		} else if (anntOwner instanceof TopLevelDecl) {
			TopLevelDecl tpLvlDclrtn = (TopLevelDecl) anntOwner;
			Declaration declaration = tpLvlDclrtn.getDeclaration();
			if (declaration != null) {
				target = declaration.eClass();
			}
		} else if (anntOwner instanceof ClassMemberDecl) {
			ClassMemberDecl declaration = (ClassMemberDecl) anntOwner;
			ClassMember member = declaration.getMember();
			if (member != null) {
				target = member.eClass();
			}
		} else if (anntOwner instanceof Param) {
			target = anntOwner.eClass();
		} else if (anntOwner instanceof EnumLiteral) {
			target = anntOwner.eClass();
		}
		return Optional.ofNullable(target);
	}
	
	private Optional<String> resolveLabel(Annotation annt) {
		StringOrQualifiedID source = annt.getSource();
		String label = null;
		label = source.getId();
		if (label == null) {
			try {
				label = this.annotationMap.labelForUri(source.getLiteral(), annt.eResource());
			} catch (NoSuchElementException e) {
				// People may use arbitrary URIs at any point
				LOG.warn("Non-registered Annotation URI used: " + source.getLiteral());
			}
		}
		return Optional.ofNullable(label);
	}
	
	
}
